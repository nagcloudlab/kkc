
# General KeyDB configuration file.
#-------------------------------------------------------------

# Run in foreground; let systemd or Docker manage the process lifecycle
daemonize no

# File to write the process ID so supervisors can track/stop the service
pidfile ./keydb.pid

# Working directory for persistence files (RDB/AOF) and temp artifacts
dir .

# Log file path (rotate with logrotate in production)
logfile ./keydb.log

# Logging verbosity: debug | verbose | notice | warning
loglevel notice

# Number of logical databases addressable via SELECT 0..N-1
databases 16

# Use OS service managers: no | upstart | systemd | auto
# (Keeps behavior consistent when started under a supervisor)
supervised no

# Enable logging to syslog (in addition to or instead of logfile)
# (Leave off unless your org standardizes on syslog)
# syslog-enabled yes

# Program name used when sending to syslog (helps log filtering)
# syslog-ident keydb

# Syslog facility (user | local0..local7), pick to match your SIEM conventions
# syslog-facility local0


# Network
#-------------------------------------------------------------

# Address(es) to listen on; keep 127.0.0.1 for local-only, or add your server IP
bind 0.0.0.0

# TCP port for plaintext connections; set to 0 if you run TLS-only later
port 6379

# Safety guard when exposed: blocks remote access unless bind/auth is set correctly
protected-mode yes

# Maximum number of pending TCP connections in the accept queue
tcp-backlog 65535

# Send TCP keepalives every N seconds to detect half-open connections
tcp-keepalive 60

# Disconnect clients that stay idle for N seconds; 0 = never timeout
timeout 0

# Hard cap on simultaneously connected clients (includes replicas, tools, apps)
maxclients 10000

# OPTIONAL: Enable a local UNIX domain socket for same-host apps (low latency)
# unixsocket /var/run/keydb/keydb.sock

# File permissions for the UNIX socket (octal). Grant group access for app user/group
# unixsocketperm 770

# Memory Management
#-------------------------------------------------------------

# LIMIT THE TOTAL MEMORY KEYDB CAN USE
# Rule of thumb:
#   - 60–70% of system RAM if persistence (RDB/AOF) is enabled
#   - 80–90% if running as a pure cache with no persistence
maxmemory 1gb

# DEFINE WHAT TO DO WHEN MEMORY LIMIT IS REACHED
# Options:
#   noeviction      = reject writes, keep existing keys (safest, but may break apps)
#   allkeys-lru     = evict least-recently-used keys, regardless of TTL
#   volatile-lru    = evict LRU keys but only those with TTL set
#   allkeys-lfu     = evict least-frequently-used (LFU) keys
#   volatile-lfu    = LFU but only keys with TTL
#   allkeys-random  = evict random keys
#   volatile-random = evict random keys with TTL
maxmemory-policy noeviction


# Cpu & Threads
#-------------------------------------------------------------

# ENABLE MULTI-THREADED COMMAND EXECUTION
# Start with number of physical cores (or cores-1 if the box is shared)
# Benchmark and adjust based on p99 latency and throughput
# #of threads <=  #-of CPU cores
server-threads 4


# OPTIONAL: KEEP BACKGROUND HOUSEKEEPING REASONABLE
# Server cron drives periodic tasks (timeouts, defrag cycles, etc.)
# Higher values increase background work frequency but add overhead
hz 10


# Persistence
#-------------------------------------------------------------


########## [PERSISTENCE / DISK] ##########

# TAKE PERIODIC RDB SNAPSHOTS FOR FAST RESTARTS / BACKUPS
# Format: save <seconds> <changes>
# Trigger a snapshot if at least N changes occurred within T seconds
save 900 1

# Additional snapshot cadence for more active periods
save 300 10

# High-churn safety net: snapshot if 10k writes in 60s
save 60 10000

# IF A SNAPSHOT FAILS, STOP ACCEPTING WRITES (TO PROTECT DURABILITY ASSUMPTIONS)
stop-writes-on-bgsave-error yes

# COMPRESS RDB FILES TO SAVE SPACE (slight CPU overhead during save/load)
rdbcompression yes

# VERIFY RDB INTEGRITY DURING LOAD (adds a short checksum pass)
rdbchecksum yes

# SMOOTH OUT DISK PRESSURE DURING BGSAVE BY FSYNCING INCREMENTALLY
rdb-save-incremental-fsync yes


# ENABLE APPEND-ONLY FILE FOR STRONGER DURABILITY THAN RDB-ONLY
# Turn off (appendonly no) if running purely as a cache
appendonly yes

# NAME OF THE AOF FILE WRITTEN IN THE 'dir' DIRECTORY
appendfilename "appendonly.aof"

# HOW OFTEN TO FSYNC THE AOF TO DISK
# always   = fsync every write (safest, slowest)
# everysec = fsync once per second (great balance; common default)
# no       = let OS flush (fastest, risk of losing seconds of data on crash)
appendfsync everysec

# AVOID EXTRA FSYNC PRESSURE DURING AOF OR RDB REWRITES
# (Improves latency during maintenance operations)
no-appendfsync-on-rewrite yes

# USE HYBRID AOF FORMAT WITH AN RDB PREAMBLE FOR FAST RESTARTS
aof-use-rdb-preamble yes

# INCREMENTAL FSYNC DURING AOF REWRITE TO AVOID JITTER
aof-rewrite-incremental-fsync yes

# AUTO-TRIGGER AOF REWRITE WHEN FILE HAS GROWN BY THIS PERCENTAGE
# 100 means "when it has doubled" since the last rewrite
auto-aof-rewrite-percentage 100

# MINIMUM SIZE BEFORE AUTO REWRITE CAN TRIGGER
auto-aof-rewrite-min-size 64mb

# ALLOW STARTUP IF AOF TAIL LOOKS TRUNCATED AFTER CRASH (RECOVER SAFELY)
# yes = load what’s valid and continue; no = require manual repair
aof-load-truncated yes


########## [OBSERVABILITY] ##########

# RECORD COMMANDS THAT EXCEED THIS LATENCY THRESHOLD (IN MICROSECONDS)
# 10000 = 10ms. Lower to catch more events; higher to reduce noise and overhead
slowlog-log-slower-than 10000

# MAX NUMBER OF ENTRIES KEPT IN THE SLOWLOG RING BUFFER
# Older entries are dropped when the buffer is full
slowlog-max-len 256

# CAPTURE HIGH-LATENCY EVENTS ABOVE THIS THRESHOLD (IN MILLISECONDS)
# Enables the latency monitor for periodic spikes diagnostics
latency-monitor-threshold 100




########## [REPLICATION] ##########

# CONFIGURE THIS NODE AS A REPLICA OF A MASTER
# Format: replicaof <master_host> <master_port>
# Example: replicaof 10.0.0.10 6379
# Comment out if this server is the master
# replicaof <master_ip> <port>

# PASSWORD USED TO AUTHENTICATE TO THE MASTER (IF MASTER REQUIRES AUTH)
# Example: masterauth StrongMasterPass
# masterauth <password>

# MAKE REPLICA READ-ONLY (DEFAULT: yes)
# yes  = protects against accidental writes on replicas
# no   = allow writes (dangerous unless you know what you’re doing)
replica-read-only yes

# SERVE STALE DATA WHILE SYNCING WITH MASTER
# yes  = still allow reads during sync (useful for HA caching)
# no   = block clients until sync is complete
replica-serve-stale-data yes

# ENABLE DISKLESS SYNC
# Instead of creating an RDB on disk, stream snapshot directly to replicas
# Useful for fast sync on fast networks, but requires enough memory headroom
repl-diskless-sync yes

# TIME TO WAIT (SECONDS) BEFORE STARTING DISKLESS SYNC
# Allows batching if multiple replicas connect at once
repl-diskless-sync-delay 5

# REPLICATION BACKLOG SIZE
# Keeps recent write history so replicas can catch up without full resync
# Size depends on write rate and network reliability (default: 1mb)
repl-backlog-size 64mb

# TIME TO KEEP BACKLOG AFTER LAST REPLICA DISCONNECTED
# Longer values allow replicas to rejoin without full resync
repl-backlog-ttl 3600

# CONFIGURE REPLICA PRIORITY
# Lower number = higher priority to be promoted by Sentinel (0 = never promoted)
replica-priority 100

# REPLICA ANNOUNCE IP / PORT
# Use when behind NAT or container overlay networks to tell master the right address
# replica-announce-ip 192.168.1.20
# replica-announce-port 6379

